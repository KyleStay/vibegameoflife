<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Conway's Game of Life - Web Worker Accelerated</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #0a0a0a;
            margin: 0;
            padding: 0;
            overflow: hidden;
        }
        #gameCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            cursor: pointer;
            touch-action: none;
        }
        .panel {
            position: fixed;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(17, 24, 39, 0.85);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            padding: 12px;
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
            transition: opacity 0.3s ease-in-out, visibility 0.3s ease-in-out, bottom 0.3s ease-in-out;
        }
        .panel.hidden {
            opacity: 0;
            visibility: hidden;
        }
        .controls {
            bottom: 20px;
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 10px;
            z-index: 10;
            opacity: 1;
            visibility: visible;
        }
        .settings-panel {
            position: fixed;
            bottom: -100%; /* Start hidden */
            width: clamp(300px, 90%, 500px);
            display: grid;
            gap: 1rem;
            padding: 20px;
            padding-top: 40px; /* Add padding to avoid overlap with close button */
            z-index: 11; /* Ensure settings are on top of controls */
            opacity: 0;
            visibility: hidden;
        }
        .settings-panel.visible {
            opacity: 1;
            visibility: visible;
        }
        .btn {
            background-color: rgba(31, 41, 55, 0.7);
            color: #f3f4f6;
            font-weight: 500;
            padding: 10px 20px;
            border-radius: 8px;
            border: none;
            cursor: pointer;
            transition: all 0.2s ease;
            white-space: nowrap;
        }
        .btn:hover {
            background-color: rgba(55, 65, 81, 0.9);
            transform: translateY(-2px);
        }
        .btn.active {
            background-color: #dc2626; /* Red for active kill mode */
            color: white;
        }
        #startStopBtn.active {
             background-color: #0e7490;
        }
        .form-group {
            display: grid;
            grid-template-columns: 1fr auto;
            align-items: center;
            gap: 10px;
        }
        .form-group label {
            font-weight: 500;
            color: #d1d5db;
        }
        .input-group {
            display: flex;
            align-items: center;
            gap: 8px;
            background: rgba(55, 65, 81, 0.8);
            padding: 4px;
            border-radius: 6px;
        }
        .input-group input[type="number"] {
            width: 50px;
            background: transparent;
            border: none;
            color: white;
            text-align: center;
            -moz-appearance: textfield;
        }
        .input-group input[type="number"]::-webkit-inner-spin-button { display: none; }
        .input-group button {
            width: 24px;
            height: 24px;
            background: #4b5563;
            border-radius: 4px;
            color: white;
            font-weight: bold;
        }
        input[type="range"] {
            width: 100%;
            grid-column: span 2;
        }
        select {
            background: rgba(55, 65, 81, 0.8);
            color: white;
            border: 1px solid #4b5563;
            border-radius: 6px;
            padding: 8px;
        }
        input[type="color"] {
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
            width: 80px;
            height: 36px;
            background-color: transparent;
            border: 1px solid #4b5563;
            border-radius: 6px;
            cursor: pointer;
        }
        input[type="color"]::-webkit-color-swatch-wrapper { padding: 0; }
        input[type="color"]::-webkit-color-swatch { border: none; border-radius: 5px; }
        #killCursor {
            position: absolute;
            border-radius: 50%;
            background-color: rgba(220, 38, 38, 0.3);
            border: 1px solid rgba(220, 38, 38, 0.7);
            transform: translate(-50%, -50%);
            pointer-events: none; /* Allows clicks to pass through to the canvas */
            z-index: 100;
        }
    </style>
</head>
<body>

    <canvas id="gameCanvas"></canvas>
    <div id="killCursor" class="hidden"></div>

    <div id="settingsPanel" class="panel settings-panel">
        <button id="closeSettingsBtn" class="absolute top-2 right-2 text-gray-400 hover:text-white text-3xl leading-none px-2 rounded">&times;</button>
        <div class="form-group">
            <label for="resolutionInput">Square Size</label>
            <div class="input-group">
                <button data-for="resolutionInput" data-step="-1">-</button>
                <input type="number" id="resolutionInput" data-key="resolution" min="1" max="30">
                <button data-for="resolutionInput" data-step="1">+</button>
            </div>
            <input type="range" id="resolutionSlider" min="1" max="30">
        </div>
        <div class="form-group">
            <label for="fpsInput">Frame Rate</label>
            <div class="input-group">
                <button data-for="fpsInput" data-step="-1">-</button>
                <input type="number" id="fpsInput" data-key="frameRate" min="1" max="144">
                <button data-for="fpsInput" data-step="1">+</button>
            </div>
            <input type="range" id="fpsSlider" min="1" max="144">
        </div>
        <div class="form-group">
            <label for="colorPicker">Cell Color</label>
            <input type="color" id="colorPicker">
        </div>
        <div class="form-group">
            <label for="colorEffectSelect">Color Effect</label>
            <select id="colorEffectSelect">
                <option value="0">Static</option>
                <option value="1">Rainbow</option>
                <option value="2">Neighbor Count</option>
                <option value="3">Age</option>
                <option value="4">Shape Size</option>
            </select>
        </div>
    </div>

    <div id="controlsPanel" class="panel controls">
        <button id="startStopBtn" class="btn">Start</button>
        <button id="stepBtn" class="btn">Step</button>
        <button id="randomizeBtn" class="btn">Randomize</button>
        <button id="resetBtn" class="btn">Reset</button>
        <button id="settingsBtn" class="btn">Settings</button>
        <button id="killModeBtn" class="btn">Kill</button>
        <button id="fullscreenBtn" class="btn">Fullscreen</button>
        <button id="hideBtn" class="btn">Hide</button>
    </div>

<script id="vertex-shader" type="x-shader/x-vertex">
    precision highp float;
    attribute vec2 a_position;
    attribute vec3 a_color;

    uniform vec2 u_canvasResolution;
    uniform float u_pointSize;

    varying vec3 v_color;

    void main() {
        // Center the position on the pixel to avoid rounding errors and gaps.
        vec2 centered_position = a_position + 0.5;

        // Convert cell coordinates (e.g., 0 to cols) to clip space (-1.0 to 1.0)
        vec2 zeroToOne = centered_position / u_canvasResolution;
        vec2 zeroToTwo = zeroToOne * 2.0;
        vec2 clipSpace = zeroToTwo - 1.0;

        gl_Position = vec4(clipSpace * vec2(1.0, -1.0), 0.0, 1.0);
        gl_PointSize = u_pointSize;
        v_color = a_color;
    }
</script>

<script id="fragment-shader" type="x-shader/x-fragment">
    precision highp float;
    varying vec3 v_color;

    void main() {
        // By checking the coordinate within the point, we can discard the anti-aliased edges,
        // effectively creating a sharp square instead of a soft circle.
        vec2 coord = gl_PointCoord - 0.5;
        if (abs(coord.x) > 0.5 || abs(coord.y) > 0.5) {
            discard;
        }
        gl_FragColor = vec4(v_color, 1.0);
    }
</script>

<script id="worker-script" type="javascript/worker">
    // --- Web Worker Logic ---

    // These functions are duplicated in the worker for self-containment.
    function cellKey(col, row) { return `${col},${row}`; }
    function fromCellKey(key) { return key.split(',').map(Number); }

    onmessage = function(e) {
        const { liveCellsArray, cols, rows } = e.data;
        const liveCells = new Map(liveCellsArray);

        const nextLiveCells = new Map();
        const neighborCounts = new Map();

        for (const [key, age] of liveCells.entries()) {
            const [col, row] = fromCellKey(key);
            for (let i = -1; i < 2; i++) {
                for (let j = -1; j < 2; j++) {
                    if (i === 0 && j === 0) continue;
                    const x = (col + i + cols) % cols;
                    const y = (row + j + rows) % rows;
                    const neighborKey = cellKey(x, y);
                    neighborCounts.set(neighborKey, (neighborCounts.get(neighborKey) || 0) + 1);
                }
            }
        }

        for (const [key, count] of neighborCounts.entries()) {
            const isAlive = liveCells.has(key);
            if (count === 3 || (isAlive && count === 2)) {
                const newAge = isAlive ? liveCells.get(key) + 1 : 1;
                nextLiveCells.set(key, newAge);
            }
        }

        // Convert Map back to array for transferring back to the main thread.
        postMessage(Array.from(nextLiveCells.entries()));
    };
</script>

<script>
    const canvas = document.getElementById('gameCanvas');
    const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
    const killCursor = document.getElementById('killCursor');
    let renderProgram;
    let positionBuffer, colorBuffer;
    let cols = 0, rows = 0;
    let animationId;
    let isRunning = false, isDrawing = false, uiVisible = true, isKillMode = false;
    let liveCells = new Map();
    let time = 0;
    let worker;
    let isCalculating = false;

    let settings = {
        resolution: 3,
        frameRate: 30,
        cellColor: [6/255, 182/255, 212/255],
        colorEffect: 4
    };

    function createShader(gl, type, source) {
        const shader = gl.createShader(type);
        gl.shaderSource(shader, source);
        gl.compileShader(shader);
        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
            console.error('Shader compilation error: ' + gl.getShaderInfoLog(shader));
            gl.deleteShader(shader);
            return null;
        }
        return shader;
    }

    function createProgram(gl, vertexShader, fragmentShader) {
        const program = gl.createProgram();
        gl.attachShader(program, vertexShader);
        gl.attachShader(program, fragmentShader);
        gl.linkProgram(program);
        if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
            console.error('Shader program link error: ' + gl.getProgramInfoLog(program));
            return null;
        }
        return program;
    }

    function setupWebGL() {
        if (!gl) {
            alert('WebGL is not supported by your browser.');
            return false;
        }

        const vertexShaderSource = document.getElementById('vertex-shader').textContent;
        const fragmentShaderSource = document.getElementById('fragment-shader').textContent;

        const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
        const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);

        renderProgram = createProgram(gl, vertexShader, fragmentShader);

        positionBuffer = gl.createBuffer();
        colorBuffer = gl.createBuffer();
        return true;
    }

    function setupWorker() {
        const workerCode = document.getElementById('worker-script').textContent;
        const blob = new Blob([workerCode], { type: 'application/javascript' });
        worker = new Worker(URL.createObjectURL(blob));

        worker.onmessage = function(e) {
            liveCells = new Map(e.data);
            isCalculating = false;
            if (isRunning) {
                render();
                animationId = setTimeout(gameLoop, 1000 / settings.frameRate);
            }
        };
    }

    function cellKey(col, row) { return `${col},${row}`; }
    function fromCellKey(key) { return key.split(',').map(Number); }

    function nextGen() {
        if (isCalculating) return;
        isCalculating = true;
        worker.postMessage({ liveCellsArray: Array.from(liveCells.entries()), cols, rows });
    }

    function render() {
        gl.clearColor(0.04, 0.04, 0.04, 1.0);
        gl.clear(gl.COLOR_BUFFER_BIT);

        if (liveCells.size === 0) return;

        const positions = new Float32Array(liveCells.size * 2);
        const colors = new Float32Array(liveCells.size * 3);
        let i = 0;

        let shapeMap;
        if (settings.colorEffect === 4) {
            shapeMap = findShapes();
        }

        for (const [key, age] of liveCells.entries()) {
            const [col, row] = fromCellKey(key);

            positions[i * 2] = col * settings.resolution;
            positions[i * 2 + 1] = row * settings.resolution;

            let r, g, b;
            switch (settings.colorEffect) {
                case 1: // Rainbow
                    const frequency = 0.05;
                    const hue = (Math.sin(col * frequency + time) + Math.cos(row * frequency + time) + 2) / 4;
                    [r, g, b] = hslToRgb(hue, 0.9, 0.6);
                    break;
                case 2: // Neighbor Count
                    const neighborCount = getNeighborCount(col, row);
                    [r, g, b] = getNeighborColor(neighborCount);
                    break;
                case 3: // Age
                    const normalizedAge = Math.min(age / 50.0, 1.0);
                    [r, g, b] = hslToRgb(0.55 - normalizedAge, 0.9, 0.6);
                    break;
                case 4: // Shape Size
                    const size = shapeMap.get(key) || 1;
                    [r, g, b] = hslToRgb(size * 0.05 % 1.0, 0.85, 0.6);
                    break;
                default: // Static
                    [r, g, b] = settings.cellColor;
                    break;
            }
            colors[i * 3] = r;
            colors[i * 3 + 1] = g;
            colors[i * 3 + 2] = b;
            i++;
        }

        gl.useProgram(renderProgram);

        const positionLocation = gl.getAttribLocation(renderProgram, 'a_position');
        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, positions, gl.DYNAMIC_DRAW);
        gl.enableVertexAttribArray(positionLocation);
        gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);

        const colorLocation = gl.getAttribLocation(renderProgram, 'a_color');
        gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, colors, gl.DYNAMIC_DRAW);
        gl.enableVertexAttribArray(colorLocation);
        gl.vertexAttribPointer(colorLocation, 3, gl.FLOAT, false, 0, 0);

        const canvasResLoc = gl.getUniformLocation(renderProgram, "u_canvasResolution");
        const pointSizeLoc = gl.getUniformLocation(renderProgram, "u_pointSize");
        gl.uniform2f(canvasResLoc, canvas.width, canvas.height);
        gl.uniform1f(pointSizeLoc, settings.resolution);

        gl.drawArrays(gl.POINTS, 0, liveCells.size);
    }

    function gameLoop() {
        if (!isRunning) return;
        time += 0.02;
        nextGen(); // This will trigger the worker
    }

    function resizeCanvas() {
        const dpr = window.devicePixelRatio || 1;
        canvas.width = Math.round(window.innerWidth * dpr);
        canvas.height = Math.round(window.innerHeight * dpr);
        gl.viewport(0, 0, canvas.width, canvas.height);

        cols = Math.ceil(canvas.width / settings.resolution);
        rows = Math.ceil(canvas.height / settings.resolution);
        randomizeGrid();
    }

    function randomizeGrid() {
        liveCells.clear();
        for (let r = 0; r < rows; r++) {
            for (let c = 0; c < cols; c++) {
                if (Math.random() > 0.8) {
                    liveCells.set(cellKey(c, r), 1);
                }
            }
        }
        render();
    }

    function resetGrid() {
        liveCells.clear();
        render();
    }

    function modifyCells(event) {
        const rect = canvas.getBoundingClientRect();
        const dpr = window.devicePixelRatio || 1;
        const x = (event.clientX - rect.left) * dpr;
        const y = (event.clientY - rect.top) * dpr;

        const col = Math.floor(x / settings.resolution);
        const row = Math.floor(y / settings.resolution);

        if (isKillMode) {
            const radius = 5; // 10x10 area
            for (let i = -radius; i <= radius; i++) {
                for (let j = -radius; j <= radius; j++) {
                    if (i*i + j*j <= radius*radius) { // circular brush
                        const key = cellKey((col + i + cols) % cols, (row + j + rows) % rows);
                        liveCells.delete(key);
                    }
                }
            }
        } else {
            if (col >= 0 && col < cols && row >= 0 && row < rows) {
                const key = cellKey(col, row);
                if (liveCells.has(key)) {
                    liveCells.delete(key);
                } else {
                    liveCells.set(key, 1);
                }
            }
        }
        render();
    }

    function findShapes() {
        const visited = new Set();
        const shapeMap = new Map();
        for (const key of liveCells.keys()) {
            if (!visited.has(key)) {
                const shape = [];
                const stack = [key];
                visited.add(key);
                while (stack.length > 0) {
                    const currentKey = stack.pop();
                    shape.push(currentKey);
                    const [c, r] = fromCellKey(currentKey);
                    for (let i = -1; i < 2; i++) {
                        for (let j = -1; j < 2; j++) {
                            if (i === 0 && j === 0) continue;
                            const neighborKey = cellKey((c + i + cols) % cols, (r + j + rows) % rows);
                            if (liveCells.has(neighborKey) && !visited.has(neighborKey)) {
                                visited.add(neighborKey);
                                stack.push(neighborKey);
                            }
                        }
                    }
                }
                const shapeSize = shape.length;
                for (const shapeKey of shape) {
                    shapeMap.set(shapeKey, shapeSize);
                }
            }
        }
        return shapeMap;
    }

    function hslToRgb(h, s, l) {
        let r, g, b;
        if (s == 0) {
            r = g = b = l;
        } else {
            const hue2rgb = (p, q, t) => {
                if (t < 0) t += 1;
                if (t > 1) t -= 1;
                if (t < 1/6) return p + (q - p) * 6 * t;
                if (t < 1/2) return q;
                if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
                return p;
            };
            const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
            const p = 2 * l - q;
            r = hue2rgb(p, q, h + 1/3);
            g = hue2rgb(p, q, h);
            b = hue2rgb(p, q, h - 1/3);
        }
        return [r, g, b];
    }

    function getNeighborColor(count) {
        const colors = [
            [0.01, 0.02, 0.37], [0.0, 0.47, 0.71], [0.02, 0.84, 0.63],
            [1.0, 0.84, 0.04], [0.98, 0.34, 0.22], [0.94, 0.36, 0.71],
            [0.85, 0.02, 0.16], [0.29, 0.0, 0.12], [0.29, 0.0, 0.12]
        ];
        return colors[Math.floor(count)];
    }

    function getNeighborCount(col, row) {
        let count = 0;
        for (let i = -1; i < 2; i++) {
            for (let j = -1; j < 2; j++) {
                if (i === 0 && j === 0) continue;
                if (liveCells.has(cellKey((col + i + cols) % cols, (row + j + rows) % rows))) {
                    count++;
                }
            }
        }
        return count;
    }

    const ui = {
        init() {
            document.getElementById('startStopBtn').addEventListener('click', ui.toggleRun);
            document.getElementById('stepBtn').addEventListener('click', () => { if(!isRunning) { nextGen(); }});
            document.getElementById('randomizeBtn').addEventListener('click', () => { randomizeGrid(); });
            document.getElementById('resetBtn').addEventListener('click', () => { resetGrid(); });
            document.getElementById('settingsBtn').addEventListener('click', ui.toggleSettings);
            document.getElementById('killModeBtn').addEventListener('click', ui.toggleKillMode);
            document.getElementById('closeSettingsBtn').addEventListener('click', ui.toggleSettings);
            document.getElementById('hideBtn').addEventListener('click', ui.hide);
            document.getElementById('fullscreenBtn').addEventListener('click', ui.toggleFullscreen);

            canvas.addEventListener('mousedown', ui.handleMouseDown);
            canvas.addEventListener('mousemove', ui.handleMouseMove);
            canvas.addEventListener('mouseup', () => isDrawing = false);
            canvas.addEventListener('mouseleave', () => {
                isDrawing = false;
                killCursor.classList.add('hidden');
            });
            canvas.addEventListener('mouseenter', (e) => {
                if (isKillMode) {
                    killCursor.classList.remove('hidden');
                    ui.updateKillCursor(e);
                }
            });

            document.getElementById('resolutionInput').addEventListener('change', e => ui.updateSetting('resolution', e.target.value));
            document.getElementById('resolutionSlider').addEventListener('input', e => ui.updateSetting('resolution', e.target.value));
            document.getElementById('fpsInput').addEventListener('change', e => ui.updateSetting('frameRate', e.target.value));
            document.getElementById('fpsSlider').addEventListener('input', e => ui.updateSetting('frameRate', e.target.value));
            document.getElementById('colorPicker').addEventListener('input', e => {
                const hex = e.target.value;
                settings.cellColor = [parseInt(hex.slice(1,3), 16)/255, parseInt(hex.slice(3,5), 16)/255, parseInt(hex.slice(5,7), 16)/255];
                if (!isRunning) render();
            });
            document.getElementById('colorEffectSelect').addEventListener('change', e => {
                settings.colorEffect = parseInt(e.target.value);
                if (!isRunning) render();
            });

            document.querySelectorAll('.input-group button').forEach(btn => {
                btn.addEventListener('click', () => {
                    const input = document.getElementById(btn.dataset.for);
                    let value = parseInt(input.value) + parseInt(btn.dataset.step);
                    value = Math.max(parseInt(input.min), Math.min(parseInt(input.max), value));
                    ui.updateSetting(input.dataset.key, value);
                });
            });
        },
        toggleSettings() {
            const panel = document.getElementById('settingsPanel');
            const isVisible = panel.classList.toggle('visible');
            if (isVisible) {
                ui.updateSettingsPanelPosition();
            } else {
                panel.style.bottom = '';
            }
        },
        updateSettingsPanelPosition() {
            const controlsPanel = document.getElementById('controlsPanel');
            const settingsPanel = document.getElementById('settingsPanel');
            if (controlsPanel && settingsPanel) {
                const controlsHeight = controlsPanel.offsetHeight;
                const bottomOffset = controlsHeight + 20 + 10;
                settingsPanel.style.bottom = `${bottomOffset}px`;
            }
        },
        toggleRun() {
            isRunning = !isRunning;
            document.getElementById('startStopBtn').textContent = isRunning ? 'Stop' : 'Start';
            document.getElementById('startStopBtn').classList.toggle('active', isRunning);
            if (isRunning) gameLoop(); else clearTimeout(animationId);
        },
        toggleKillMode() {
            isKillMode = !isKillMode;
            document.getElementById('killModeBtn').classList.toggle('active', isKillMode);
            if (!isKillMode) {
                killCursor.classList.add('hidden');
            }
        },
        hide() {
            document.getElementById('controlsPanel').classList.add('hidden');
            document.getElementById('settingsPanel').classList.remove('visible');
            uiVisible = false;
        },
        toggleFullscreen() {
            if (!document.fullscreenElement) document.documentElement.requestFullscreen();
            else document.exitFullscreen();
        },
        handleMouseDown(e) {
            if (!uiVisible) {
                document.getElementById('controlsPanel').classList.remove('hidden');
                uiVisible = true;
                return;
            }
            isDrawing = true;
            modifyCells(e);
        },
        handleMouseMove(e) {
            if (isKillMode) ui.updateKillCursor(e);
            if (isDrawing && uiVisible) {
                modifyCells(e);
            }
        },
        updateKillCursor(e) {
            if (isKillMode && uiVisible) {
                killCursor.classList.remove('hidden');
                killCursor.style.left = `${e.clientX}px`;
                killCursor.style.top = `${e.clientY}px`;
                const size = settings.resolution * 10;
                killCursor.style.width = `${size}px`;
                killCursor.style.height = `${size}px`;
            }
        },
        updateSetting(key, value) {
            const numValue = parseInt(value);
            if (isNaN(numValue)) return;
            settings[key] = numValue;
            if (key === 'resolution') {
                if (numValue < 1) settings.resolution = 1;
                document.getElementById('resolutionInput').value = settings.resolution;
                document.getElementById('resolutionSlider').value = settings.resolution;
                resizeCanvas();
            } else if (key === 'frameRate') {
                document.getElementById('fpsInput').value = numValue;
                document.getElementById('fpsSlider').value = numValue;
            }
        },
        initialize() {
            document.getElementById('resolutionInput').value = settings.resolution;
            document.getElementById('resolutionSlider').value = settings.resolution;
            document.getElementById('fpsInput').value = settings.frameRate;
            document.getElementById('fpsSlider').value = settings.frameRate;
            document.getElementById('colorPicker').value = `#${settings.cellColor.map(c => Math.round(c*255).toString(16).padStart(2,'0')).join('')}`;
            document.getElementById('colorEffectSelect').value = settings.colorEffect;
        }
    };

    window.addEventListener('load', () => {
        setupWorker();
        if (setupWebGL()) {
            ui.initialize();
            ui.init();
            resizeCanvas();
        }
    });
    window.addEventListener('resize', () => {
        resizeCanvas();
        if (document.getElementById('settingsPanel').classList.contains('visible')) {
            ui.updateSettingsPanelPosition();
        }
    });
</script>
</body>
</html>
