<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Kyle's Vibe Coded Conway's Game of Life</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #0a0a0a;
            color: #f3f4f6;
            margin: 0;
            padding: 0;
            overflow: hidden;
        }
        #gameCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            cursor: pointer;
            touch-action: none;
        }
        .panel {
            position: fixed;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(17, 24, 39, 0.85);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            padding: 12px;
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
            transition: opacity 0.3s ease-in-out, visibility 0.3s ease-in-out, bottom 0.3s ease-in-out;
        }
        .panel.hidden {
            opacity: 0;
            visibility: hidden;
            pointer-events: none;
        }
        .controls {
            bottom: 20px;
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 10px;
            z-index: 10;
            width: clamp(320px, 90%, 900px);
        }
        .settings-panel {
            position: fixed;
            bottom: -100%; /* Start hidden */
            width: clamp(300px, 90%, 500px);
            display: grid;
            gap: 1rem;
            padding: 20px;
            padding-top: 40px;
            z-index: 11;
            opacity: 0;
            visibility: hidden;
            max-height: 65vh;
            overflow-y: auto;
        }
        .settings-panel.visible {
            opacity: 1;
            visibility: visible;
        }
        .btn, .select-btn-container {
            background-color: rgba(31, 41, 55, 0.7);
            color: #f3f4f6;
            font-weight: 500;
            border-radius: 8px;
            border: none;
            cursor: pointer;
            transition: all 0.2s ease;
            white-space: nowrap;
            position: relative;
            padding: 10px 20px;
        }
        .select-btn {
            padding-right: 3rem;
        }
        .btn:hover, .select-btn-container:hover {
            background-color: rgba(55, 65, 81, 0.9);
            transform: translateY(-2px);
        }
        .btn.active {
            background-color: #dc2626;
            color: white;
        }
        #startStopBtn.active {
             background-color: #0e7490;
        }
        .form-group {
            display: grid;
            grid-template-columns: 1fr auto;
            align-items: center;
            gap: 10px;
        }
        .form-group label {
            font-weight: 500;
            color: #d1d5db;
        }
        .input-group {
            display: flex;
            align-items: center;
            gap: 8px;
            background: rgba(55, 65, 81, 0.8);
            padding: 4px;
            border-radius: 6px;
        }
        .input-group input[type="number"] {
            width: 50px;
            background: transparent;
            border: none;
            color: white;
            text-align: center;
            -moz-appearance: textfield;
        }
        .input-group input[type="number"]::-webkit-inner-spin-button { display: none; }
        .input-group button {
            width: 24px;
            height: 24px;
            background: #4b5563;
            border-radius: 4px;
            color: white;
            font-weight: bold;
        }
        input[type="range"] {
            width: 100%;
            grid-column: span 2;
        }
        select {
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
            background: transparent;
            width: 100%;
            height: 100%;
            cursor: pointer;
        }
        input[type="color"] {
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
            width: 80px;
            height: 36px;
            background-color: transparent;
            border: 1px solid #4b5563;
            border-radius: 6px;
            cursor: pointer;
        }
        input[type="color"]::-webkit-color-swatch-wrapper { padding: 0; }
        input[type="color"]::-webkit-color-swatch { border: none; border-radius: 5px; }
        #killCursor {
            position: absolute;
            border-radius: 50%;
            background-color: rgba(220, 38, 38, 0.3);
            border: 1px solid rgba(220, 38, 38, 0.7);
            transform: translate(-50%, -50%);
            pointer-events: none;
            z-index: 100;
        }
        .mini-controls {
            position: fixed;
            bottom: 20px;
            right: 20px;
            display: flex;
            gap: 10px;
            z-index: 12;
        }
        .mini-btn {
            width: 56px;
            height: 56px;
            border-radius: 50%;
            background-color: rgba(31, 41, 55, 0.8);
            border: 1px solid rgba(255, 255, 255, 0.1);
            color: white;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        .mini-btn:hover {
            background-color: rgba(55, 65, 81, 0.9);
            transform: scale(1.1);
        }
        .mini-btn.active {
            background-color: #dc2626;
        }
        #miniStartStopBtn.active {
             background-color: #0e7490;
        }
        /* Rules Screen Styles */
        #rulesScreen {
            position: fixed;
            inset: 0;
            background-color: rgba(10, 10, 10, 0.95);
            backdrop-filter: blur(10px);
            z-index: 20;
            overflow-y: auto;
            padding: 2rem;
            display: none;
        }
        .rule-card {
            background-color: #1f2937;
            border-radius: 12px;
            padding: 1.5rem;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        .mini-canvas {
            width: 100%;
            aspect-ratio: 1.5;
            background-color: #111827;
            border-radius: 8px;
            margin-bottom: 1rem;
        }
    </style>
</head>
<body class="antialiased">

    <div id="gameContainer">
        <canvas id="gameCanvas"></canvas>
        <div id="killCursor" class="hidden"></div>

        <div id="settingsPanel" class="panel settings-panel">
            <button id="closeSettingsBtn" class="absolute top-2 right-2 text-gray-400 hover:text-white text-3xl leading-none px-2 rounded">&times;</button>
            <div class="form-group">
                <label for="resolutionInput">Square Size</label>
                <div class="input-group"><button data-for="resolutionInput" data-step="-1">-</button><input type="number" id="resolutionInput" data-key="resolution" min="1" max="30"><button data-for="resolutionInput" data-step="1">+</button></div>
                <input type="range" id="resolutionSlider" min="1" max="30">
            </div>
            <div class="form-group">
                <label for="frameRateInput">Frame Rate</label>
                <div class="input-group"><button data-for="frameRateInput" data-step="-1">-</button><input type="number" id="frameRateInput" data-key="frameRate" min="1" max="144"><button data-for="frameRateInput" data-step="1">+</button></div>
                <input type="range" id="frameRateSlider" min="1" max="144">
            </div>
            <div id="rainbowSpeedGroup" class="form-group">
                <label for="rainbowSpeedInput">Rainbow Speed</label>
                <div class="input-group"><button data-for="rainbowSpeedInput" data-step="-0.1">-</button><input type="number" id="rainbowSpeedInput" data-key="rainbowSpeed" min="0.1" max="5" step="0.1"><button data-for="rainbowSpeedInput" data-step="0.1">+</button></div>
                <input type="range" id="rainbowSpeedSlider" min="0.1" max="5" step="0.1">
            </div>
            <div id="colorPickerGroup" class="form-group">
                <label for="colorPicker">Cell Color</label>
                <input type="color" id="colorPicker">
            </div>
            <div class="form-group">
                <label for="colorEffectSelect">Color Effect</label>
                <div class="relative">
                    <select id="colorEffectSelect" class="btn pr-10">
                        <option value="0">Static</option>
                        <option value="1">Rainbow</option>
                        <option value="2">Neighbor Count</option>
                        <option value="3">Age</option>
                        <option value="4">Shape Size</option>
                        <option value="5">Synthwave</option>
                        <option value="6">Bioluminescence</option>
                        <option value="7">Scorched Earth</option>
                        <option value="8">Blueprint</option>
                        <option value="9">Monochrome</option>
                        <option value="10">Local Density</option>
                        <option value="11">Shape Velocity</option>
                        <option value="12">Generational Diversity</option>
                        <option value="13">Stability</option>
                        <option value="14">Growth Rate</option>
                        <option value="15">Neighborhood Chaos</option>
                        <option value="16">Proximity</option>
                        <option value="17">Collision Flash</option>
                        <option value="18">Ghosting</option>
                        <option value="19">Fertility</option>
                    </select>
                    <div class="pointer-events-none absolute inset-y-0 right-0 flex items-center px-2 text-gray-400"><svg class="fill-current h-4 w-4" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M9.293 12.95l.707.707L15.657 8l-1.414-1.414L10 10.828 5.757 6.586 4.343 8z"/></svg></div>
                </div>
            </div>
        </div>

        <div id="controlsPanel" class="panel controls">
            <button id="startStopBtn" class="btn">Start</button>
            <button id="stepBtn" class="btn">Step</button>
            <div class="relative btn hover:transform-none">
                <select id="seedSelect" class="absolute top-0 left-0 w-full h-full opacity-0 cursor-pointer">
                    <option value="random">Random</option>
                    <optgroup label="Still Lifes"><option value="block">Block</option><option value="beehive">Beehive</option><option value="loaf">Loaf</option><option value="boat">Boat</option><option value="tub">Tub</option></optgroup>
                    <optgroup label="Spaceships"><option value="glider">Glider</option><option value="lwss">Lightweight Spaceship</option><option value="mwss">Middleweight Spaceship</option><option value="hwss">Heavyweight Spaceship</option><option value="copperhead">Copperhead</option></optgroup>
                    <optgroup label="Oscillators"><option value="blinker">Blinker</option><option value="toad">Toad</option><option value="beacon">Beacon</option><option value="pulsar">Pulsar</option><option value="pentadecathlon">Pentadecathlon</option><option value="figureEight">Figure Eight</option></optgroup>
                    <optgroup label="Guns & Puffers"><option value="gosperGliderGun">Gosper Glider Gun</option><option value="simkinGliderGun">Simkin Glider Gun</option><option value="blockLayingSwitchEngine">Block Laying Switch Engine</option></optgroup>
                    <optgroup label="Methuselahs"><option value="rPentomino">R-pentomino</option><option value="acorn">Acorn</option><option value="diehard">Diehard</option></optgroup>
                    <optgroup label="Exotic"><option value="gliderDuplicator">Glider Duplicator</option><option value="max">Max</option></optgroup>
                </select>
                <span id="seedSelectLabel">Random</span>
                <div class="pointer-events-none absolute inset-y-0 right-0 flex items-center px-2 text-gray-400"><svg class="fill-current h-4 w-4" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M9.293 12.95l.707.707L15.657 8l-1.414-1.414L10 10.828 5.757 6.586 4.343 8z"/></svg></div>
            </div>
            <button id="resetBtn" class="btn">Reset</button>
            <button id="rulesBtn" class="btn">Rules</button>
            <button id="settingsBtn" class="btn">Settings</button>
            <button id="killModeBtn" class="btn">Kill</button>
            <button id="fullscreenBtn" class="btn">Fullscreen</button>
            <button id="hideBtn" class="btn">Hide</button>
        </div>

        <div id="miniControlsPanel" class="mini-controls hidden">
            <button id="miniStartStopBtn" class="mini-btn"><svg id="playIcon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="5 3 19 12 5 21 5 3"></polygon></svg><svg id="pauseIcon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="hidden"><rect x="6" y="4" width="4" height="16"></rect><rect x="14" y="4" width="4" height="16"></rect></svg></button>
            <button id="miniKillModeBtn" class="mini-btn"><svg id="drawIcon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 20h9"></path><path d="M16.5 3.5a2.121 2.121 0 0 1 3 3L7 19l-4 1 1-4L16.5 3.5z"></path></svg><svg id="killIcon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="hidden"><path d="M20 20a2 2 0 0 0 2-2V6a2 2 0 0 0-2-2H4a2 2 0 0 0-2 2v12a2 2 0 0 0 2 2Z"></path><path d="M16 16.5 8 8.5"></path><path d="m8 16.5 8-8"></path></svg></button>
            <button id="unhideBtn" class="mini-btn"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M2 12s3-7 10-7 10 7 10 7-3 7-10 7-10-7-10-7Z"></path><circle cx="12" cy="12" r="3"></circle></svg></button>
            <button id="hideAllBtn" class="mini-btn"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M9.88 9.88a3 3 0 1 0 4.24 4.24"/><path d="M10.73 5.08A10.43 10.43 0 0 1 12 5c7 0 10 7 10 7a13.16 13.16 0 0 1-1.67 2.68"/><path d="M6.61 6.61A13.526 13.526 0 0 0 2 12s3 7 10 7a9.74 9.74 0 0 0 5.39-1.61"/><line x1="2" x2="22" y1="2" y2="22"/></svg></button>
        </div>
    </div>

    <div id="rulesScreen">
        <div class="max-w-4xl mx-auto p-6 sm:p-8">
            <div class="flex justify-between items-center mb-8">
                 <h1 class="text-3xl sm:text-4xl font-bold text-cyan-400 text-center">The Rules of Life</h1>
                 <button id="closeRulesBtn" class="text-gray-400 hover:text-white text-4xl leading-none px-3 py-1 rounded-full">&times;</button>
            </div>
            <p class="text-center text-gray-400 mb-12 max-w-2xl mx-auto">The universe of the Game of Life is an infinite grid of square cells. Each cell can be in one of two states: alive or dead. Every cell interacts with its eight neighbours, which are the cells that are horizontally, vertically, or diagonally adjacent.</p>
            <div class="grid grid-cols-1 md:grid-cols-2 gap-8">
                <div class="rule-card">
                    <h2 class="text-xl font-bold text-white mb-2">1. Underpopulation</h2>
                    <p class="text-gray-400 mb-4">A living (<span class="text-yellow-300 font-semibold">yellow</span>) cell with **fewer than two** live neighbours (<span class="text-cyan-300 font-semibold">cyan</span>) dies.</p>
                    <canvas class="mini-canvas" id="rule1-canvas" width="300" height="200"></canvas>
                    <button class="btn w-full replay-btn" data-sim="0">Play Example</button>
                </div>
                <div class="rule-card">
                    <h2 class="text-xl font-bold text-white mb-2">2. Survival</h2>
                    <p class="text-gray-400 mb-4">A living (<span class="text-yellow-300 font-semibold">yellow</span>) cell with **two or three** live neighbours (<span class="text-cyan-300 font-semibold">cyan</span>) survives.</p>
                    <canvas class="mini-canvas" id="rule2-canvas" width="300" height="200"></canvas>
                    <button class="btn w-full replay-btn" data-sim="1">Play Example</button>
                </div>
                <div class="rule-card">
                    <h2 class="text-xl font-bold text-white mb-2">3. Overpopulation</h2>
                    <p class="text-gray-400 mb-4">A living (<span class="text-yellow-300 font-semibold">yellow</span>) cell with **more than three** live neighbours (<span class="text-cyan-300 font-semibold">cyan</span>) dies.</p>
                    <canvas class="mini-canvas" id="rule3-canvas" width="300" height="200"></canvas>
                    <button class="btn w-full replay-btn" data-sim="2">Play Example</button>
                </div>
                <div class="rule-card">
                    <h2 class="text-xl font-bold text-white mb-2">4. Reproduction</h2>
                    <p class="text-gray-400 mb-4">A dead (<span class="font-semibold text-gray-400">dark gray</span>) cell with **exactly three** live neighbours (<span class="text-cyan-300 font-semibold">cyan</span>) becomes a live cell.</p>
                    <canvas class="mini-canvas" id="rule4-canvas" width="300" height="200"></canvas>
                    <button class="btn w-full replay-btn" data-sim="3">Play Example</button>
                </div>
            </div>
        </div>
    </div>

<script id="vertex-shader" type="x-shader/x-vertex">
    precision highp float;
    attribute vec2 a_position;
    attribute vec3 a_color;

    uniform vec2 u_canvasResolution;
    uniform float u_pointSize;

    varying vec3 v_color;

    void main() {
        vec2 centered_position = a_position + 0.5;
        vec2 zeroToOne = centered_position / u_canvasResolution;
        vec2 zeroToTwo = zeroToOne * 2.0;
        vec2 clipSpace = zeroToTwo - 1.0;
        gl_Position = vec4(clipSpace * vec2(1.0, -1.0), 0.0, 1.0);
        gl_PointSize = u_pointSize;
        v_color = a_color;
    }
</script>

<script id="fragment-shader" type="x-shader/x-fragment">
    precision highp float;
    varying vec3 v_color;

    void main() {
        vec2 coord = gl_PointCoord - 0.5;
        if (abs(coord.x) > 0.5 || abs(coord.y) > 0.5) {
            discard;
        }
        gl_FragColor = vec4(v_color, 1.0);
    }
</script>

<script id="worker-script" type="javascript/worker">
    // --- Web Worker Logic ---

    function cellKey(col, row) { return `${col},${row}`; }
    function fromCellKey(key) { return key.split(',').map(Number); }

    onmessage = function(e) {
        const { liveCellsArray, cols, rows } = e.data;
        const liveCells = new Map(liveCellsArray);

        const nextLiveCells = new Map();
        const neighborCounts = new Map();

        for (const [key, age] of liveCells.entries()) {
            const [col, row] = fromCellKey(key);
            for (let i = -1; i < 2; i++) {
                for (let j = -1; j < 2; j++) {
                    if (i === 0 && j === 0) continue;
                    const x = (col + i + cols) % cols;
                    const y = (row + j + rows) % rows;
                    const neighborKey = cellKey(x, y);
                    neighborCounts.set(neighborKey, (neighborCounts.get(neighborKey) || 0) + 1);
                }
            }
        }

        for (const [key, count] of neighborCounts.entries()) {
            const isAlive = liveCells.has(key);
            if (count === 3 || (isAlive && count === 2)) {
                const newAge = isAlive ? liveCells.get(key) + 1 : 1;
                nextLiveCells.set(key, newAge);
            }
        }

        postMessage(Array.from(nextLiveCells.entries()));
    };
</script>

<script>
    const canvas = document.getElementById('gameCanvas');
    const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
    const killCursor = document.getElementById('killCursor');
    let renderProgram;
    let positionBuffer, colorBuffer;
    let cols = 0, rows = 0;
    let animationId;
    let isRunning = false, isDrawing = false, isKillMode = false;
    let uiState = 'full'; // 'full', 'mini', 'hidden'
    let liveCells = new Map();
    let previousLiveCells = new Map();
    let time = 0;
    let worker;
    let isCalculating = false;
    let previousShapes = new Map();
    let collisionCells = new Map();
    let ghostCells = new Map();
    let fertilityMap = new Map();

    let settings = {
        resolution: 3,
        frameRate: 60,
        rainbowSpeed: 1.0,
        cellColor: [6/255, 182/255, 212/255],
        colorEffect: 4
    };

    const seeds = {
        gosperGliderGun: [[24,0],[22,1],[24,1],[12,2],[13,2],[20,2],[21,2],[34,2],[35,2],[11,3],[15,3],[20,3],[21,3],[34,3],[35,3],[0,4],[1,4],[10,4],[16,4],[20,4],[21,4],[0,5],[1,5],[10,5],[14,5],[16,5],[17,5],[22,5],[24,5],[10,6],[16,6],[24,6],[11,7],[15,7],[12,8],[13,8]],
        simkinGliderGun: [[0,0],[1,0],[5,0],[6,0],[7,0],[8,0],[10,0],[11,0],[12,0],[13,0],[14,0],[18,0],[19,0],[20,0],[2,2],[3,2],[5,2],[6,2],[10,2],[11,2],[18,2],[19,2],[2,3],[3,3],[5,3],[6,3],[10,3],[11,3],[18,3],[19,3],[5,4],[6,4],[10,4],[11,4],[0,5],[1,5],[5,5],[6,5],[10,5],[11,5],[13,6],[14,6],[18,6],[19,6],[13,7],[14,7],[18,7],[19,7],[15,8],[16,8],[15,9],[16,9]],
        pulsar: [[4,0],[5,0],[6,0],[10,0],[11,0],[12,0],[2,2],[7,2],[9,2],[14,2],[2,3],[7,3],[9,3],[14,3],[2,4],[7,4],[9,4],[14,4],[4,5],[5,5],[6,5],[10,5],[11,5],[12,5],[4,7],[5,7],[6,7],[10,7],[11,7],[12,7],[2,8],[7,8],[9,8],[14,8],[2,9],[7,9],[9,9],[14,9],[2,10],[7,10],[9,10],[14,10],[4,12],[5,12],[6,12],[10,12],[11,12],[12,12]],
        pentadecathlon: [[4,0],[3,1],[4,1],[5,1],[4,2],[4,3],[4,4],[3,5],[4,5],[5,5]],
        glider: [[1,0],[2,1],[0,2],[1,2],[2,2]],
        lwss: [[1,0],[2,0],[3,0],[4,0],[0,1],[4,1],[4,2],[0,3],[3,3]],
        mwss: [[1,0],[2,0],[3,0],[4,0],[5,0],[0,1],[5,1],[5,2],[0,3],[4,3]],
        hwss: [[1,0],[2,0],[3,0],[4,0],[5,0],[6,0],[0,1],[6,1],[6,2],[0,3],[5,3]],
        copperhead: [[0,0],[1,0],[3,0],[4,0],[1,1],[3,1],[2,2]],
        rPentomino: [[1,0],[0,1],[1,1],[1,2],[2,2]],
        acorn: [[1,0],[3,1],[0,2],[1,2],[4,2],[5,2],[6,2]],
        diehard: [[6,0],[0,1],[1,1],[1,2],[5,2],[6,2],[7,2]],
        blockLayingSwitchEngine: [[0,0],[1,0],[2,0],[3,0],[4,0],[5,0],[7,0],[8,0],[9,0],[10,0],[1,2],[2,2],[3,2],[4,2],[8,2],[9,2],[10,2],[11,2],[3,4],[4,4],[8,4],[9,4]],
        gliderDuplicator: [[0,0],[1,0],[2,0],[0,1],[1,1],[1,2],[4,3],[5,3],[6,3],[7,3],[8,3],[4,4],[5,4],[6,4],[7,4],[8,4],[5,5],[6,5],[7,5],[20,20],[21,20],[22,20],[20,21],[21,21],[21,22]],
        block: [[0,0],[1,0],[0,1],[1,1]],
        beehive: [[1,0],[2,0],[0,1],[3,1],[1,2],[2,2]],
        loaf: [[1,0],[2,0],[0,1],[3,1],[1,2],[3,2],[2,3]],
        tub: [[1,0],[0,1],[2,1],[1,2]],
        boat: [[0,0],[1,0],[0,1],[2,1],[1,2]],
        ship: [[0,0],[1,0],[0,1],[2,1],[1,2],[2,2]],
        blinker: [[0,1],[1,1],[2,1]],
        toad: [[1,0],[2,0],[3,0],[0,1],[1,1],[2,1]],
        beacon: [[0,0],[1,0],[0,1],[3,2],[2,3],[3,3]],
        figureEight: [[2,0],[3,0],[4,0],[0,1],[1,1],[5,1],[0,2],[5,2],[0,3],[5,3],[2,4],[3,4],[4,4]],
        max: [[1,0],[2,0],[0,1],[3,1],[1,2],[2,2]]
    };

    function createShader(gl, type, source) {
        const shader = gl.createShader(type);
        gl.shaderSource(shader, source);
        gl.compileShader(shader);
        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
            console.error('Shader compilation error: ' + gl.getShaderInfoLog(shader));
            gl.deleteShader(shader);
            return null;
        }
        return shader;
    }

    function createProgram(gl, vertexShader, fragmentShader) {
        const program = gl.createProgram();
        gl.attachShader(program, vertexShader);
        gl.attachShader(program, fragmentShader);
        gl.linkProgram(program);
        if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
            console.error('Shader program link error: ' + gl.getProgramInfoLog(program));
            return null;
        }
        return program;
    }

    function setupWebGL() {
        if (!gl) {
            alert('WebGL is not supported by your browser.');
            return false;
        }

        const vertexShaderSource = document.getElementById('vertex-shader').textContent;
        const fragmentShaderSource = document.getElementById('fragment-shader').textContent;

        const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
        const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);

        renderProgram = createProgram(gl, vertexShader, fragmentShader);

        positionBuffer = gl.createBuffer();
        colorBuffer = gl.createBuffer();
        return true;
    }

    function setupWorker() {
        const workerCode = document.getElementById('worker-script').textContent;
        const blob = new Blob([workerCode], { type: 'application/javascript' });
        worker = new Worker(URL.createObjectURL(blob));

        worker.onmessage = function(e) {
            previousLiveCells = new Map(liveCells);
            liveCells = new Map(e.data);
            isCalculating = false;

            if (isRunning) {
                render();
                animationId = setTimeout(gameLoop, 1000 / settings.frameRate);
            } else {
                render();
            }
        };
    }

    function cellKey(col, row) { return `${col},${row}`; }
    function fromCellKey(key) { return key.split(',').map(Number); }

    function nextGen() {
        if (isCalculating) return;
        isCalculating = true;
        worker.postMessage({ liveCellsArray: Array.from(liveCells.entries()), cols, rows });
    }

    function lerp(a, b, t) { return a * (1 - t) + b * t; }
    function lerpColor(c1, c2, t) { return [lerp(c1[0], c2[0], t), lerp(c1[1], c2[1], t), lerp(c1[2], c2[2], t)]; }

    function render() {
        let bgColor = [0.04, 0.04, 0.04, 1.0];
        switch (settings.colorEffect) {
            case 5: bgColor = [26/255, 16/255, 60/255, 1.0]; break;
            case 6: bgColor = [3/255, 7/255, 30/255, 1.0]; break;
            case 7: bgColor = [28/255, 25/255, 23/255, 1.0]; break;
            case 8: bgColor = [59/255, 89/255, 152/255, 1.0]; break;
            case 9: bgColor = [1.0, 1.0, 1.0, 1.0]; break;
        }
        gl.clearColor(...bgColor);
        gl.clear(gl.COLOR_BUFFER_BIT);

        // Update historical data for special themes
        updateGhostCells();
        if (settings.colorEffect === 19) {
            updateFertilityMap();
        }


        const allCells = [...liveCells.entries()];
        const allGhosts = settings.colorEffect === 18 ? [...ghostCells.entries()] : [];
        const totalPoints = allCells.length + allGhosts.length;

        if (totalPoints === 0) return;

        const positions = new Float32Array(totalPoints * 2);
        const colors = new Float32Array(totalPoints * 3);
        let i = 0;

        let metricMap;
        if (settings.colorEffect >= 4 && settings.colorEffect <= 17) {
            metricMap = analyzeMetrics();
        } else {
            metricMap = new Map();
        }

        // Render live cells
        for (const [key, age] of allCells) {
            const [col, row] = fromCellKey(key);

            positions[i * 2] = col * settings.resolution;
            positions[i * 2 + 1] = row * settings.resolution;

            let r, g, b;
            const normalizedAge = Math.min(age / 50.0, 1.0);

            switch (settings.colorEffect) {
                case 1: // Rainbow
                    const angle = time * 0.1;
                    const s = Math.sin(angle);
                    const c = Math.cos(angle);
                    const rotatedCol = col * c - row * s;
                    const rotatedRow = col * s + row * c;
                    const frequency = 0.03 + Math.sin(time * 0.2) * 0.02;
                    const hue = (Math.sin(rotatedCol * frequency) + Math.cos(rotatedRow * frequency) + 2) / 4;
                    [r, g, b] = hslToRgb(hue, 0.9, 0.6);
                    break;
                case 2: // Neighbor Count
                    [r, g, b] = getNeighborColor(getNeighborCount(col, row));
                    break;
                case 3: // Age
                    [r, g, b] = hslToRgb(0.55 - normalizedAge, 0.9, 0.6);
                    break;
                case 4: // Shape Size
                    [r, g, b] = hslToRgb((metricMap.get(key)?.size || 1) * 0.05 % 1.0, 0.85, 0.6);
                    break;
                case 5: // Synthwave
                    [r, g, b] = lerpColor([1, 0, 1], [0, 1, 1], normalizedAge);
                    break;
                case 6: // Bioluminescence
                    [r, g, b] = [45/255, 212/255, 191/255];
                    break;
                case 7: // Scorched Earth
                    const fireColor1 = [249/255, 115/255, 22/255], fireColor2 = [220/255, 38/255, 38/255], fireColor3 = [69/255, 10/255, 10/255];
                    [r, g, b] = normalizedAge < 0.5 ? lerpColor(fireColor1, fireColor2, normalizedAge * 2) : lerpColor(fireColor2, fireColor3, (normalizedAge - 0.5) * 2);
                    break;
                case 8: // Blueprint
                    [r, g, b] = [241/255, 245/255, 249/255];
                    break;
                case 9: // Monochrome
                    [r, g, b] = [0, 0, 0];
                    break;
                case 10: // Local Density
                    const density = metricMap.get(key)?.density || 0;
                    const normDensity = Math.min(density / 50, 1.0);
                    [r, g, b] = hslToRgb(0.6 - normDensity * 0.6, 0.9, 0.6);
                    break;
                case 11: // Shape Velocity
                    const speed = metricMap.get(key)?.velocity || 0;
                    const normSpeed = Math.min(speed / 2.0, 1.0);
                    [r, g, b] = hslToRgb(0.6 - normSpeed * 0.6, 0.9, 0.6);
                    break;
                case 12: // Generational Diversity
                    const diversity = metricMap.get(key)?.diversity || 0;
                    const normDiversity = Math.min(diversity / 100, 1.0);
                    [r, g, b] = lerpColor([1, 1, 1], [0.5, 0, 1], normDiversity);
                    break;
                case 13: // Stability
                    const stability = metricMap.get(key)?.stability || 0; // 0: chaotic, 1: oscillator, 2: stable
                    if (stability === 2) [r, g, b] = [0.2, 0.4, 1.0]; // Cool blue
                    else if (stability === 1) [r, g, b] = [0.2, 0.8, 1.0]; // Cyan
                    else [r, g, b] = [1.0, 0.8, 0.2]; // Yellow
                    break;
                case 14: // Growth Rate
                    const rate = metricMap.get(key)?.growthRate || 0; // -1 to 1
                    if (rate > 0.01) [r, g, b] = lerpColor([0.5, 0.5, 0.5], [0, 1, 0], rate * 10); // Gray to Green
                    else if (rate < -0.01) [r, g, b] = lerpColor([0.5, 0.5, 0.5], [1, 0, 0], Math.abs(rate) * 10); // Gray to Red
                    else [r, g, b] = [0.5, 0.5, 0.5]; // Gray
                    break;
                case 15: // Neighborhood Chaos
                    const chaos = metricMap.get(key)?.chaos || 0;
                    const normChaos = Math.min(chaos / 8, 1.0); // Max 8 neighbors can flip
                    [r, g, b] = hslToRgb(0.6 - normChaos * 0.6, 1.0, 0.55); // Blue (calm) to Red (chaotic)
                    break;
                case 16: // Proximity
                    const dist = metricMap.get(key)?.proximity || 0;
                    const normDist = Math.min(dist / 15, 1.0); // Max search distance
                    [r, g, b] = hslToRgb(0.3 + normDist * 0.4, 0.9, 0.6); // Green to Purple
                    break;
                case 17: // Collision Flash
                    const flashTTL = collisionCells.get(key);
                    if (flashTTL) {
                        const flashAmt = flashTTL / 4.0;
                        [r, g, b] = [flashAmt, flashAmt, flashAmt];
                    } else {
                        [r, g, b] = settings.cellColor;
                    }
                    break;
                case 19: // Fertility
                    const fertility = fertilityMap.get(key) || 0;
                    [r, g, b] = lerpColor([0.2, 0.2, 0.8], [1, 1, 0.2], Math.min(fertility / 3, 1.0)); // Blue to Yellow
                    break;
                default: // Static
                    [r, g, b] = settings.cellColor;
                    break;
            }
            colors[i * 3] = r;
            colors[i * 3 + 1] = g;
            colors[i * 3 + 2] = b;
            i++;
        }

        // Render ghost cells
        for (const [key, ttl] of allGhosts) {
            const [col, row] = fromCellKey(key);
            positions[i * 2] = col * settings.resolution;
            positions[i * 2 + 1] = row * settings.resolution;
            const brightness = ttl / 10.0;
            colors[i * 3] = 0.2 * brightness;
            colors[i * 3 + 1] = 0.5 * brightness;
            colors[i * 3 + 2] = 0.8 * brightness;
            i++;
        }

        gl.useProgram(renderProgram);
        const positionLocation = gl.getAttribLocation(renderProgram, 'a_position');
        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, positions, gl.DYNAMIC_DRAW);
        gl.enableVertexAttribArray(positionLocation);
        gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);
        const colorLocation = gl.getAttribLocation(renderProgram, 'a_color');
        gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, colors, gl.DYNAMIC_DRAW);
        gl.enableVertexAttribArray(colorLocation);
        gl.vertexAttribPointer(colorLocation, 3, gl.FLOAT, false, 0, 0);
        const canvasResLoc = gl.getUniformLocation(renderProgram, "u_canvasResolution");
        const pointSizeLoc = gl.getUniformLocation(renderProgram, "u_pointSize");
        gl.uniform2f(canvasResLoc, canvas.width, canvas.height);
        gl.uniform1f(pointSizeLoc, settings.resolution);
        gl.drawArrays(gl.POINTS, 0, totalPoints);
    }

    function gameLoop() {
        if (!isRunning) return;
        time += 0.02 * settings.rainbowSpeed;
        nextGen();
    }

    function resizeCanvas() {
        const dpr = window.devicePixelRatio || 1;
        canvas.width = Math.round(window.innerWidth * dpr);
        canvas.height = Math.round(window.innerHeight * dpr);
        gl.viewport(0, 0, canvas.width, canvas.height);
        cols = Math.ceil(canvas.width / settings.resolution);
        rows = Math.ceil(canvas.height / settings.resolution);
        loadSeed('random');
    }

    function loadSeed(seedName) {
        previousShapes.clear();
        collisionCells.clear();
        ghostCells.clear();
        fertilityMap.clear();
        if (seedName === 'random') {
            randomizeGrid();
            return;
        }
        liveCells.clear();
        const pattern = seeds[seedName];
        if (!pattern) return;
        const centerX = Math.floor(cols / 2);
        const centerY = Math.floor(rows / 2);
        for (const [x, y] of pattern) {
            liveCells.set(cellKey(centerX + x, centerY + y), 1);
        }
        render();
    }

    function randomizeGrid() {
        previousShapes.clear();
        liveCells.clear();
        for (let r = 0; r < rows; r++) {
            for (let c = 0; c < cols; c++) {
                if (Math.random() > 0.8) {
                    liveCells.set(cellKey(c, r), 1);
                }
            }
        }
        render();
    }

    function resetGrid() {
        previousShapes.clear();
        liveCells.clear();
        render();
    }

    function modifyCells(event) {
        const rect = canvas.getBoundingClientRect();
        const dpr = window.devicePixelRatio || 1;
        const clientX = event.touches ? event.touches[0].clientX : event.clientX;
        const clientY = event.touches ? event.touches[0].clientY : event.clientY;
        const x = (clientX - rect.left) * dpr;
        const y = (clientY - rect.top) * dpr;
        const col = Math.floor(x / settings.resolution);
        const row = Math.floor(y / settings.resolution);

        if (isKillMode) {
            const radius = 10;
            for (let i = -radius; i <= radius; i++) {
                for (let j = -radius; j <= radius; j++) {
                    if (i*i + j*j <= radius*radius) {
                        liveCells.delete(cellKey((col + i + cols) % cols, (row + j + rows) % rows));
                    }
                }
            }
        } else {
            if (col >= 0 && col < cols && row >= 0 && row < rows) {
                const key = cellKey(col, row);
                if (liveCells.has(key)) liveCells.delete(key);
                else liveCells.set(key, 1);
            }
        }
        render();
    }

    function analyzeMetrics() {
        const metricMap = new Map();
        const visited = new Set();
        const currentShapes = new Map();
        let shapeIdCounter = 0;

        const cellToShapeId = new Map();

        for (const key of liveCells.keys()) {
            if (!visited.has(key)) {
                const shapeCells = [];
                const stack = [key];
                visited.add(key);
                let sumX = 0, sumY = 0, minAge = Infinity, maxAge = 0;
                const prevShapeIds = new Set();

                while (stack.length > 0) {
                    const currentKey = stack.pop();
                    shapeCells.push(currentKey);
                    const [c, r] = fromCellKey(currentKey);
                    const age = liveCells.get(currentKey);
                    sumX += c;
                    sumY += r;
                    if (age < minAge) minAge = age;
                    if (age > maxAge) maxAge = age;

                    if (previousShapes.has(currentKey)) {
                        prevShapeIds.add(previousShapes.get(currentKey).id);
                    }

                    for (let i = -1; i < 2; i++) {
                        for (let j = -1; j < 2; j++) {
                            const neighborKey = cellKey((c + i + cols) % cols, (r + j + rows) % rows);
                            if (liveCells.has(neighborKey) && !visited.has(neighborKey)) {
                                visited.add(neighborKey);
                                stack.push(neighborKey);
                            }
                        }
                    }
                }

                const shapeSize = shapeCells.length;
                const centerOfMass = { x: sumX / shapeSize, y: sumY / shapeSize };
                const diversity = maxAge - minAge;

                let speed = 0, stability = 0, growthRate = 0;
                let bestMatchId = -1;

                if (prevShapeIds.size === 1) { // Matched to one previous shape
                    bestMatchId = [...prevShapeIds][0];
                    const prevShape = previousShapes.get(bestMatchId);
                    if (prevShape) {
                        const dx = centerOfMass.x - prevShape.centerOfMass.x;
                        const dy = centerOfMass.y - prevShape.centerOfMass.y;
                        speed = Math.sqrt(dx*dx + dy*dy);
                        growthRate = (shapeSize - prevShape.size) / prevShape.size;
                        if (speed < 0.1 && shapeSize === prevShape.size) stability = 2;
                        else if (speed < 1.0 && shapeSize === prevShape.size) stability = 1;
                    }
                } else if (prevShapeIds.size > 1) { // Collision detected
                     shapeCells.forEach(k => collisionCells.set(k, 4)); // Flash for 4 frames
                }

                const currentShapeId = (bestMatchId !== -1) ? bestMatchId : shapeIdCounter++;
                currentShapes.set(currentShapeId, { centerOfMass, size: shapeSize, cells: shapeCells });

                for (const cellKey of shapeCells) {
                    cellToShapeId.set(cellKey, currentShapeId);
                    metricMap.set(cellKey, {
                        size: shapeSize,
                        velocity: speed,
                        diversity: diversity,
                        stability: stability,
                        growthRate: growthRate,
                    });
                }
            }
        }
        previousShapes.clear();
        for(const [id, shape] of currentShapes.entries()) {
            for(const key of shape.cells) {
                previousShapes.set(key, { id, centerOfMass: shape.centerOfMass, size: shape.size });
            }
        }

        // Proximity calculation (if needed)
        if (settings.colorEffect === 16) {
            for (const [key, metrics] of metricMap.entries()) {
                const [c, r] = fromCellKey(key);
                metrics.proximity = findNearestNeighborDistance(c, r, cellToShapeId.get(key), cellToShapeId);
            }
        }

        return metricMap;
    }

    function findNearestNeighborDistance(startX, startY, myShapeId, cellToShapeId) {
        const queue = [{x: startX, y: startY, dist: 0}];
        const visited = new Set(cellKey(startX, startY));
        const maxDist = 15;

        while(queue.length > 0) {
            const {x, y, dist} = queue.shift();
            if (dist >= maxDist) return maxDist;

            for (let i = -1; i <= 1; i++) {
                for (let j = -1; j <= 1; j++) {
                    if (i === 0 && j === 0) continue;
                    const nx = x + i;
                    const ny = y + j;
                    const nKey = cellKey(nx, ny);
                    if (!visited.has(nKey)) {
                        visited.add(nKey);
                        if (liveCells.has(nKey)) {
                            if (cellToShapeId.get(nKey) !== myShapeId) {
                                return dist + 1;
                            }
                        }
                        queue.push({x: nx, y: ny, dist: dist + 1});
                    }
                }
            }
        }
        return maxDist;
    }

    function updateGhostCells() {
        const newGhosts = new Map();
        for (const [key, ttl] of ghostCells.entries()) {
            if (ttl > 1) newGhosts.set(key, ttl - 1);
        }
        for (const key of previousLiveCells.keys()) {
            if (!liveCells.has(key)) {
                newGhosts.set(key, 10); // 10 frames TTL
            }
        }
        ghostCells = newGhosts;
    }

    function updateFertilityMap() {
        fertilityMap.clear();
        for (const key of liveCells.keys()) {
            if (liveCells.get(key) === 1) { // Is newly born
                const [c, r] = fromCellKey(key);
                for (let i = -1; i <= 1; i++) {
                    for (let j = -1; j <= 1; j++) {
                        if (i === 0 && j === 0) continue;
                        const neighborKey = cellKey(c + i, r + j);
                        if (previousLiveCells.has(neighborKey)) {
                            fertilityMap.set(neighborKey, (fertilityMap.get(neighborKey) || 0) + 1);
                        }
                    }
                }
            }
        }
    }

    function calculateLocalDensityMap() {
        const densityMap = new Map();
        const radius = 6;
        for (const key of liveCells.keys()) {
            const [c, r] = fromCellKey(key);
            let density = 0;
            for (let i = -radius; i <= radius; i++) {
                for (let j = -radius; j <= radius; j++) {
                    if (liveCells.has(cellKey(c + i, r + j))) {
                        density++;
                    }
                }
            }
            densityMap.set(key, {density});
        }
        return densityMap;
    }

    function calculateChaosMap() {
        const chaosMap = new Map();
        const allKeys = new Set([...liveCells.keys(), ...previousLiveCells.keys()]);

        for (const key of allKeys) {
            const [c, r] = fromCellKey(key);
            let chaos = 0;
            for (let i = -1; i <= 1; i++) {
                for (let j = -1; j <= 1; j++) {
                    if (i === 0 && j === 0) continue;
                    const neighborKey = cellKey(c + i, r + j);
                    if (liveCells.has(neighborKey) !== previousLiveCells.has(neighborKey)) {
                        chaos++;
                    }
                }
            }
            if(liveCells.has(key)) {
                chaosMap.set(key, {chaos});
            }
        }
        return chaosMap;
    }


    function hslToRgb(h, s, l) {
        let r, g, b;
        if (s == 0) { r = g = b = l; } else {
            const hue2rgb = (p, q, t) => {
                if (t < 0) t += 1; if (t > 1) t -= 1;
                if (t < 1/6) return p + (q - p) * 6 * t;
                if (t < 1/2) return q;
                if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
                return p;
            };
            const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
            const p = 2 * l - q;
            r = hue2rgb(p, q, h + 1/3); g = hue2rgb(p, q, h); b = hue2rgb(p, q, h - 1/3);
        }
        return [r, g, b];
    }

    function getNeighborColor(count) {
        const colors = [
            [0.01, 0.02, 0.37], [0.0, 0.47, 0.71], [0.02, 0.84, 0.63],
            [1.0, 0.84, 0.04], [0.98, 0.34, 0.22], [0.94, 0.36, 0.71],
            [0.85, 0.02, 0.16], [0.29, 0.0, 0.12], [0.29, 0.0, 0.12]
        ];
        return colors[Math.min(Math.floor(count), 8)];
    }

    function getNeighborCount(col, row) {
        let count = 0;
        for (let i = -1; i < 2; i++) {
            for (let j = -1; j < 2; j++) {
                if (i === 0 && j === 0) continue;
                if (liveCells.has(cellKey((col + i + cols) % cols, (row + j + rows) % rows))) {
                    count++;
                }
            }
        }
        return count;
    }

    const ui = {
        init() {
            document.getElementById('startStopBtn').addEventListener('click', ui.toggleRun);
            document.getElementById('stepBtn').addEventListener('click', () => { if(!isRunning) { nextGen(); }});
            document.getElementById('seedSelect').addEventListener('change', (e) => {
                loadSeed(e.target.value);
                document.getElementById('seedSelectLabel').textContent = e.target.options[e.target.selectedIndex].text;
            });
            document.getElementById('resetBtn').addEventListener('click', () => { resetGrid(); });
            document.getElementById('settingsBtn').addEventListener('click', ui.toggleSettings);
            document.getElementById('killModeBtn').addEventListener('click', ui.toggleKillMode);
            document.getElementById('closeSettingsBtn').addEventListener('click', ui.toggleSettings);
            document.getElementById('hideBtn').addEventListener('click', ui.hide);
            document.getElementById('fullscreenBtn').addEventListener('click', ui.toggleFullscreen);
            document.getElementById('unhideBtn').addEventListener('click', ui.unhide);
            document.getElementById('miniStartStopBtn').addEventListener('click', ui.toggleRun);
            document.getElementById('miniKillModeBtn').addEventListener('click', ui.toggleKillMode);
            document.getElementById('hideAllBtn').addEventListener('click', ui.hideAll);
            document.getElementById('rulesBtn').addEventListener('click', ui.showRules);
            document.getElementById('closeRulesBtn').addEventListener('click', ui.hideRules);

            canvas.addEventListener('mousedown', ui.handleMouseDown);
            canvas.addEventListener('mousemove', ui.handleMouseMove);
            canvas.addEventListener('mouseup', () => isDrawing = false);
            canvas.addEventListener('mouseleave', () => { isDrawing = false; killCursor.classList.add('hidden'); });
            canvas.addEventListener('mouseenter', (e) => { if (isKillMode) { killCursor.classList.remove('hidden'); ui.updateKillCursor(e); } });
            canvas.addEventListener('touchstart', ui.handleMouseDown, { passive: false });
            canvas.addEventListener('touchmove', ui.handleMouseMove, { passive: false });
            canvas.addEventListener('touchend', () => isDrawing = false);

            document.getElementById('resolutionInput').addEventListener('change', e => ui.updateSetting('resolution', e.target.value));
            document.getElementById('resolutionSlider').addEventListener('input', e => ui.updateSetting('resolution', e.target.value));
            document.getElementById('frameRateInput').addEventListener('change', e => ui.updateSetting('frameRate', e.target.value));
            document.getElementById('frameRateSlider').addEventListener('input', e => ui.updateSetting('frameRate', e.target.value));
            document.getElementById('rainbowSpeedInput').addEventListener('change', e => ui.updateSetting('rainbowSpeed', e.target.value));
            document.getElementById('rainbowSpeedSlider').addEventListener('input', e => ui.updateSetting('rainbowSpeed', e.target.value));
            document.getElementById('colorPicker').addEventListener('input', e => {
                const hex = e.target.value;
                settings.cellColor = [parseInt(hex.slice(1,3), 16)/255, parseInt(hex.slice(3,5), 16)/255, parseInt(hex.slice(5,7), 16)/255];
                if (!isRunning) render();
            });
            document.getElementById('colorEffectSelect').addEventListener('change', e => {
                settings.colorEffect = parseInt(e.target.value);
                document.getElementById('colorPickerGroup').style.display = (settings.colorEffect === 0) ? 'grid' : 'none';
                document.getElementById('rainbowSpeedGroup').style.display = (settings.colorEffect === 1) ? 'grid' : 'none';
                if (!isRunning) render();
            });

            document.querySelectorAll('.input-group button').forEach(btn => {
                btn.addEventListener('click', () => {
                    const input = document.getElementById(btn.dataset.for);
                    const step = parseFloat(btn.dataset.step);
                    let value = parseFloat(input.value) + step;
                    value = Math.max(parseFloat(input.min), Math.min(parseFloat(input.max), value));
                    if(input.dataset.key) ui.updateSetting(input.dataset.key, value);
                });
            });
        },
        toggleSettings() {
            const panel = document.getElementById('settingsPanel');
            const isVisible = panel.classList.toggle('visible');
            if (isVisible) {
                ui.updateSettingsPanelPosition();
            } else {
                panel.style.bottom = '';
            }
        },
        updateSettingsPanelPosition() {
            const controlsPanel = document.getElementById('controlsPanel');
            const settingsPanel = document.getElementById('settingsPanel');
            if (controlsPanel && settingsPanel) {
                const controlsHeight = controlsPanel.offsetHeight;
                const bottomOffset = controlsHeight + 20 + 10;
                settingsPanel.style.bottom = `${bottomOffset}px`;
            }
        },
        toggleRun() {
            isRunning = !isRunning;
            document.getElementById('startStopBtn').classList.toggle('active', isRunning);
            document.getElementById('miniStartStopBtn').classList.toggle('active', isRunning);
            document.getElementById('playIcon').classList.toggle('hidden', isRunning);
            document.getElementById('pauseIcon').classList.toggle('hidden', !isRunning);
            if (isRunning) gameLoop(); else clearTimeout(animationId);
        },
        toggleKillMode() {
            isKillMode = !isKillMode;
            document.getElementById('killModeBtn').classList.toggle('active', isKillMode);
            document.getElementById('miniKillModeBtn').classList.toggle('active', isKillMode);
            document.getElementById('drawIcon').classList.toggle('hidden', isKillMode);
            document.getElementById('killIcon').classList.toggle('hidden', !isKillMode);
            if (!isKillMode) {
                killCursor.classList.add('hidden');
            }
        },
        hide() {
            uiState = 'mini';
            document.getElementById('controlsPanel').classList.add('hidden');
            document.getElementById('settingsPanel').classList.remove('visible');
            document.getElementById('miniControlsPanel').classList.remove('hidden');
        },
        unhide() {
            uiState = 'full';
            document.getElementById('controlsPanel').classList.remove('hidden');
            document.getElementById('miniControlsPanel').classList.add('hidden');
        },
        hideAll() {
            uiState = 'hidden';
            document.getElementById('miniControlsPanel').classList.add('hidden');
        },
        toggleFullscreen() {
            if (!document.fullscreenElement) document.documentElement.requestFullscreen();
            else if (document.exitFullscreen) document.exitFullscreen();
        },
        handleMouseDown(e) {
            if(e.touches) e.preventDefault();
            if (uiState === 'hidden') {
                uiState = 'mini';
                document.getElementById('miniControlsPanel').classList.remove('hidden');
                return;
            }
            isDrawing = true;
            modifyCells(e);
        },
        handleMouseMove(e) {
            if(e.touches) e.preventDefault();
            ui.updateKillCursor(e);
            if (isDrawing) {
                modifyCells(e);
            }
        },
        updateKillCursor(e) {
            if (isKillMode) {
                const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                const clientY = e.touches ? e.touches[0].clientY : e.clientY;
                killCursor.classList.remove('hidden');
                killCursor.style.left = `${clientX}px`;
                killCursor.style.top = `${clientY}px`;
                const dpr = window.devicePixelRatio || 1;
                const size = (settings.resolution * 20) / dpr;
                killCursor.style.width = `${size}px`;
                killCursor.style.height = `${size}px`;
            }
        },
        updateSetting(key, value) {
            const numValue = parseFloat(value);
            if (isNaN(numValue)) return;
            settings[key] = numValue;

            const inputEl = document.getElementById(key + 'Input');
            const sliderEl = document.getElementById(key + 'Slider');

            if (inputEl) {
                const step = inputEl.getAttribute('step');
                inputEl.value = (step && step.includes('.')) ? numValue.toFixed(1) : Math.round(numValue);
            }
            if (sliderEl) sliderEl.value = numValue;

            if (key === 'resolution') resizeCanvas();
        },
        initialize() {
            document.getElementById('resolutionInput').value = settings.resolution;
            document.getElementById('resolutionSlider').value = settings.resolution;
            document.getElementById('frameRateInput').value = settings.frameRate;
            document.getElementById('frameRateSlider').value = settings.frameRate;
            document.getElementById('rainbowSpeedInput').value = settings.rainbowSpeed.toFixed(1);
            document.getElementById('rainbowSpeedSlider').value = settings.rainbowSpeed;
            document.getElementById('colorPicker').value = `#${settings.cellColor.map(c => Math.round(c*255).toString(16).padStart(2,'0')).join('')}`;
            document.getElementById('colorEffectSelect').value = settings.colorEffect;
            document.getElementById('colorPickerGroup').style.display = (settings.colorEffect === 0) ? 'grid' : 'none';
            document.getElementById('rainbowSpeedGroup').style.display = (settings.colorEffect === 1) ? 'grid' : 'none';
        },
        showRules() {
            document.getElementById('rulesScreen').style.display = 'block';
            document.getElementById('gameContainer').style.display = 'none';
            if (isRunning) ui.toggleRun(); // Pause game
            rulesSim.init();
        },
        hideRules() {
            document.getElementById('rulesScreen').style.display = 'none';
            document.getElementById('gameContainer').style.display = 'block';
            rulesSim.stopAll();
        }
    };

    // --- Rules Screen Mini-Simulations ---
    const rulesSim = {
        sims: [],
        isInitialized: false,
        configs: [
            { center: {x: 7, y: 5, type: 'main'}, neighbors: [{x: 6, y: 5, type: 'neighbor'}] }, // Underpopulation
            { center: {x: 7, y: 5, type: 'main'}, neighbors: [{x: 6, y: 5, type: 'neighbor'}, {x: 8, y: 5, type: 'neighbor'}] }, // Survival
            { center: {x: 7, y: 5, type: 'main'}, neighbors: [{x: 6, y: 5, type: 'neighbor'}, {x: 8, y: 5, type: 'neighbor'}, {x: 6, y: 4, type: 'neighbor'}, {x: 8, y: 4, type: 'neighbor'}] }, // Overpopulation
            { center: {x: 7, y: 5, type: 'dead'}, neighbors: [{x: 6, y: 5, type: 'neighbor'}, {x: 8, y: 5, type: 'neighbor'}, {x: 7, y: 4, type: 'neighbor'}] }  // Reproduction
        ],
        init() {
            if (this.isInitialized) {
                this.sims.forEach(sim => sim.run());
                return;
            };
            this.configs.forEach((config, i) => {
                const canvasId = `rule${i+1}-canvas`;
                this.sims[i] = new MiniSim(canvasId, config);
                this.sims[i].draw();
            });
            document.querySelectorAll('.replay-btn').forEach(btn => {
                btn.onclick = () => {
                    const simIndex = parseInt(btn.dataset.sim);
                    this.sims[simIndex].run();
                };
            });
            this.isInitialized = true;
        },
        stopAll() {
            this.sims.forEach(sim => sim.stop());
        }
    };

    class MiniSim {
        constructor(canvasId, config) {
            this.canvas = document.getElementById(canvasId);
            this.ctx = this.canvas.getContext('2d');
            this.config = config;
            this.cols = 15;
            this.rows = 10;
            this.cellSize = this.canvas.width / this.cols;
            this.colors = {
                main: '#facc15', // yellow-400
                neighbor: '#67e8f9', // cyan-300
                dead: '#4b5563', // gray-600
                background: '#111827', // gray-900
            };
            this.animationTimer = null;
            this.reset();
        }

        reset() {
            this.grid = Array(this.cols * this.rows).fill(null);
            const { center, neighbors } = this.config;
            this.setCell(center.x, center.y, center.type);
            neighbors.forEach(n => this.setCell(n.x, n.y, n.type));
        }

        setCell(x, y, type) {
            if (x >= 0 && x < this.cols && y >= 0 && y < this.rows) {
                this.grid[y * this.cols + x] = type;
            }
        }

        getCell(x, y) {
            if (x < 0 || x >= this.cols || y < 0 || y >= this.rows) return null;
            return this.grid[y * this.cols + x];
        }

        draw() {
            this.ctx.fillStyle = this.colors.background;
            this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

            for (let y = 0; y < this.rows; y++) {
                for (let x = 0; x < this.cols; x++) {
                    const type = this.getCell(x, y);
                    if (type) {
                        this.ctx.fillStyle = this.colors[type];
                        // Add a small gap to make cells distinct
                        this.ctx.fillRect(x * this.cellSize + 1, y * this.cellSize + 1, this.cellSize - 2, this.cellSize - 2);
                    }
                }
            }
        }

        step() {
            const nextGrid = Array(this.cols * this.rows).fill(null);
            for (let y = 0; y < this.rows; y++) {
                for (let x = 0; x < this.cols; x++) {
                    const type = this.getCell(x, y);
                    let liveNeighbors = 0;
                    for (let i = -1; i <= 1; i++) {
                        for (let j = -1; j <= 1; j++) {
                            if (i === 0 && j === 0) continue;
                            const neighborType = this.getCell(x + i, y + j);
                            if (neighborType === 'main' || neighborType === 'neighbor') {
                                liveNeighbors++;
                            }
                        }
                    }

                    const index = y * this.cols + x;
                    if (type === 'main') {
                        if (liveNeighbors === 2 || liveNeighbors === 3) {
                            nextGrid[index] = 'main'; // Survive
                        }
                    } else if (type === 'neighbor') {
                         if (liveNeighbors === 2 || liveNeighbors === 3) {
                            nextGrid[index] = 'neighbor'; // Survive
                        }
                    }
                    else { // dead cell
                        if (liveNeighbors === 3) {
                            nextGrid[index] = 'main'; // Reproduce
                        }
                    }
                }
            }
            this.grid = nextGrid;
            this.draw();
        }

        run() {
            this.stop();
            this.reset();
            this.draw();
            this.animationTimer = setTimeout(() => {
                this.step();
            }, 800);
        }

        stop() {
            if (this.animationTimer) {
                clearTimeout(this.animationTimer);
                this.animationTimer = null;
            }
        }
    }

    // --- App Initialization ---
    window.addEventListener('load', () => {
        setupWorker();
        if (setupWebGL()) {
            ui.initialize();
            ui.init();
            resizeCanvas();
        }
    });
    window.addEventListener('resize', () => {
        resizeCanvas();
        if (document.getElementById('settingsPanel').classList.contains('visible')) {
            ui.updateSettingsPanelPosition();
        }
    });
</script>
</body>
</html>
